const std = @import("std");

tag: Tag,
loc: Loc,

pub const Index = u32;

pub const Loc = struct {
    start: u32,
    end: u32,

    const Extra = struct {
        line: u32,
        col: u32,
        line_start: u32,
        line_end: u32,
    };

    pub fn extraInfo(self: Loc, source: []const u8) Extra {
        var result = Extra{
            .line = 1,
            .col = 1,
            .line_start = 0,
            .line_end = @intCast(source.len),
        };

        for (source[0..self.start], 0..) |c, i| {
            if (c == '\n') {
                result.line += 1;
                result.line_start = @as(u32, @intCast(i)) + 1;
            }
        }

        for (source[self.end..], 0..) |c, i| {
            if (c == '\n') {
                result.line_end = self.end + @as(u32, @intCast(i));
                break;
            }
        }

        result.col += self.start - result.line_start;
        return result;
    }
};

pub const Tag = enum {
    eof,
    invalid,
    ident,
    number,
    template_args_start,
    template_args_end,
    string_literal,
    @"(",
    @")",
    @"{",
    @"}",
    @"[",
    @"]",
    @".",
    @",",
    @":",
    @";",
    @"->",
    @"@",
    @"=",
    @"==",
    @"!",
    @"!=",
    @"&",
    @"&=",
    @"&&",
    @"|",
    @"|=",
    @"||",
    @"~",
    @"+",
    @"+=",
    @"++",
    @"-",
    @"-=",
    @"--",
    @"*",
    @"*=",
    @"/",
    @"/=",
    @"%",
    @"%=",
    @"^",
    @"^=",
    @"<",
    @"<=",
    @"<<",
    @"<<=",
    @">",
    @">=",
    @">>",
    @">>=",
    @"_",

    k_enable,
    k_diagnostic,
    k_requires,
    k_fn,
    k_var,
    k_let,
    k_const,
    k_override,
    k_alias,
    k_if,
    k_else,
    k_loop,
    k_while,
    k_for,
    k_break,
    k_continue,
    k_continuing,
    k_discard,
    k_switch,
    k_case,
    k_default,
    k_return,
    k_const_assert,
    k_bitcast,
    k_bool,
    k_false,
    k_true,
    k_u32,
    k_i32,
    k_f16,
    k_f32,
    k_vec2,
    k_vec3,
    k_vec4,
    k_mat2x2,
    k_mat2x3,
    k_mat2x4,
    k_mat3x2,
    k_mat3x3,
    k_mat3x4,
    k_mat4x2,
    k_mat4x3,
    k_mat4x4,
    k_ptr,
    k_array,
    k_atomic,
    k_struct,
    k_sampler,
    k_sampler_comparison,
    k_texture_depth_2d,
    k_texture_depth_2d_array,
    k_texture_depth_cube,
    k_texture_depth_cube_array,
    k_texture_depth_multisampled_2d,
    k_texture_external,
    k_texture_multisampled_2d,
    k_texture_1d,
    k_texture_2d,
    k_texture_2d_array,
    k_texture_3d,
    k_texture_cube,
    k_texture_cube_array,
    k_texture_storage_1d,
    k_texture_storage_2d,
    k_texture_storage_2d_array,
    k_texture_storage_3d,
    k_import,
    k_from,

    pub fn symbol(self: Tag) []const u8 {
        return switch (self) {
            .eof => "EOF",
            .invalid => "invalid bytes",
            .ident => "an identifier",
            .number => "a number literal",
            .string_literal => "a string literal",
            .template_args_start => "<",
            .template_args_end => ">",

            .@"(",
            .@")",
            .@"{",
            .@"}",
            .@"[",
            .@"]",
            .@".",
            .@",",
            .@":",
            .@";",
            .@"->",
            .@"@",
            .@"=",
            .@"==",
            .@"!",
            .@"!=",
            .@"&",
            .@"&=",
            .@"&&",
            .@"|",
            .@"|=",
            .@"||",
            .@"~",
            .@"+",
            .@"+=",
            .@"++",
            .@"-",
            .@"-=",
            .@"--",
            .@"*",
            .@"*=",
            .@"/",
            .@"/=",
            .@"%",
            .@"%=",
            .@"^",
            .@"^=",
            .@"<",
            .@"<=",
            .@"<<",
            .@"<<=",
            .@">",
            .@">=",
            .@">>",
            .@">>=",
            ._,
            => |t| @tagName(t),

            .k_import => "// import",
            else => |t| @tagName(t)["k_".len..],
        };
    }
};

pub const keywords = brk: {
    @setEvalBranchQuota(3000);
    const KV = struct { []const u8, Tag };
    var kvs: [100]KV = undefined;
    var i: usize = 0;
    for (@typeInfo(Tag).Enum.fields) |f| {
        if (f.name.len >= 2 and std.mem.eql(u8, f.name[0..2], "k_")) {
            kvs[i] = KV{ f.name[2..], @enumFromInt(f.value) };
            i += 1;
        }
    }
    break :brk std.ComptimeStringMap(Tag, kvs[0..i]);
};

pub const reserved = blk: {
    @setEvalBranchQuota(3000);
    break :blk std.ComptimeStringMap(void, .{
        .{"NULL"},
        .{"Self"},
        .{"abstract"},
        .{"active"},
        .{"alignas"},
        .{"alignof"},
        .{"as"},
        .{"asm"},
        .{"asm_fragment"},
        .{"async"},
        .{"attribute"},
        .{"auto"},
        .{"await"},
        .{"become"},
        .{"binding_array"},
        .{"cast"},
        .{"catch"},
        .{"class"},
        .{"co_await"},
        .{"co_return"},
        .{"co_yield"},
        .{"coherent"},
        .{"column_major"},
        .{"common"},
        .{"compile"},
        .{"compile_fragment"},
        .{"concept"},
        .{"const_cast"},
        .{"consteval"},
        .{"constexpr"},
        .{"constinit"},
        .{"crate"},
        .{"debugger"},
        .{"decltype"},
        .{"delete"},
        .{"demote"},
        .{"demote_to_helper"},
        .{"do"},
        .{"dynamic_cast"},
        .{"enum"},
        .{"explicit"},
        .{"export"},
        .{"extends"},
        .{"extern"},
        .{"external"},
        .{"fallthrough"},
        .{"filter"},
        .{"final"},
        .{"finally"},
        .{"friend"},
        .{"from"},
        .{"fxgroup"},
        .{"get"},
        .{"goto"},
        .{"groupshared"},
        .{"highp"},
        .{"impl"},
        .{"implements"},
        .{"import"},
        .{"inline"},
        .{"instanceof"},
        .{"interface"},
        .{"layout"},
        .{"lowp"},
        .{"macro"},
        .{"macro_rules"},
        .{"match"},
        .{"mediump"},
        .{"meta"},
        .{"mod"},
        .{"module"},
        .{"move"},
        .{"mut"},
        .{"mutable"},
        .{"namespace"},
        .{"new"},
        .{"nil"},
        .{"noexcept"},
        .{"noinline"},
        .{"nointerpolation"},
        .{"noperspective"},
        .{"null"},
        .{"nullptr"},
        .{"of"},
        .{"operator"},
        .{"package"},
        .{"packoffset"},
        .{"partition"},
        .{"pass"},
        .{"patch"},
        .{"pixelfragment"},
        .{"precise"},
        .{"precision"},
        .{"premerge"},
        .{"priv"},
        .{"protected"},
        .{"pub"},
        .{"public"},
        .{"readonly"},
        .{"ref"},
        .{"regardless"},
        .{"register"},
        .{"reinterpret_cast"},
        .{"require"},
        .{"resource"},
        .{"restrict"},
        .{"self"},
        .{"set"},
        .{"shared"},
        .{"sizeof"},
        .{"smooth"},
        .{"snorm"},
        .{"static"},
        .{"static_assert"},
        .{"static_cast"},
        .{"std"},
        .{"subroutine"},
        .{"super"},
        .{"target"},
        .{"template"},
        .{"this"},
        .{"thread_local"},
        .{"throw"},
        .{"trait"},
        .{"try"},
        .{"type"},
        .{"typedef"},
        .{"typeid"},
        .{"typename"},
        .{"typeof"},
        .{"union"},
        .{"unless"},
        .{"unorm"},
        .{"unsafe"},
        .{"unsized"},
        .{"use"},
        .{"using"},
        .{"varying"},
        .{"virtual"},
        .{"volatile"},
        .{"wgsl"},
        .{"where"},
        .{"with"},
        .{"writeonly"},
        .{"yield"},
    });
};
